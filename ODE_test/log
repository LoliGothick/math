g++ -std=c++14 -Wall -Wextra -O3   -c -o main.o main.cpp
main.cpp: In instantiation of ‘LA::vector<T> func(const LA::vector<T>&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’:
main.cpp:30:34:   required from here
main.cpp:17:17: error: no match for ‘operator*’ (operand types are ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ and ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’)
  ans = - (T)1.0 * b;
                 ^
main.cpp:17:17: note: candidates are:
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const V&)
    operator * (const number<B, et_off>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
    operator * (const V& a, const number<B, et_off>& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const V&)
    operator * (number<B, et_off>&& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
    operator * (const V& a, number<B, et_off>&& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   types ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ have incompatible cv-qualifiers
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const number<B, et_on>& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const V&)
    operator * (const number<B, et_on>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const V& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note: template<class B, boost::multiprecision::expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::number<B, ET> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, ET>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const V&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note:   template argument deduction/substitution failed:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp: In substitution of ‘template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const V&) [with tag = boost::multiprecision::detail::negate; Arg1 = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >; Arg2 = void; Arg3 = void; Arg4 = void; V = LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >]’:
main.cpp:17:17:   required from ‘LA::vector<T> func(const LA::vector<T>&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’
main.cpp:30:34:   required from here
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: error: no type named ‘type’ in ‘struct boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>, LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, void, void> >’
main.cpp: In instantiation of ‘LA::vector<T> func(const LA::vector<T>&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’:
main.cpp:30:34:   required from here
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note: template<class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, V, boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note: template<class B, boost::multiprecision::expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note: template<class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<B, ET>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, ET>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const V&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note:   template argument deduction/substitution failed:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp: In substitution of ‘template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const V&) [with B = boost::multiprecision::backends::cpp_dec_float<100u>; V = LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >]’:
main.cpp:17:17:   required from ‘LA::vector<T> func(const LA::vector<T>&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’
main.cpp:30:34:   required from here
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: error: no type named ‘type’ in ‘struct boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, void, void>, void, void, void> >’
main.cpp: In instantiation of ‘LA::vector<T> func(const LA::vector<T>&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’:
main.cpp:30:34:   required from here
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note: template<class B, class B2, boost::multiprecision::expression_template_option ET> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<T2, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<T2, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<T2, ExpressionTemplates>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note: template<class B2, boost::multiprecision::expression_template_option ET, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<Backend, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/config/no_tr1/complex.hpp:21:0,
                 from /usr/local/include/boost/math/policies/error_handling.hpp:15,
                 from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/opt/rh/devtoolset-3/root/usr/include/c++/4.9.2/complex:399:5: note: template<class _Tp> std::complex<_Tp> std::operator*(const _Tp&, const std::complex<_Tp>&)
     operator*(const _Tp& __x, const complex<_Tp>& __y)
     ^
/opt/rh/devtoolset-3/root/usr/include/c++/4.9.2/complex:399:5: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const std::complex<_Tp>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/config/no_tr1/complex.hpp:21:0,
                 from /usr/local/include/boost/math/policies/error_handling.hpp:15,
                 from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/opt/rh/devtoolset-3/root/usr/include/c++/4.9.2/complex:390:5: note: template<class _Tp> std::complex<_Tp> std::operator*(const std::complex<_Tp>&, const _Tp&)
     operator*(const complex<_Tp>& __x, const _Tp& __y)
     ^
/opt/rh/devtoolset-3/root/usr/include/c++/4.9.2/complex:390:5: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const std::complex<_Tp>’
  ans = - (T)1.0 * b;
                 ^
In file included from /usr/local/include/boost/config/no_tr1/complex.hpp:21:0,
                 from /usr/local/include/boost/math/policies/error_handling.hpp:15,
                 from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:9,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/opt/rh/devtoolset-3/root/usr/include/c++/4.9.2/complex:381:5: note: template<class _Tp> std::complex<_Tp> std::operator*(const std::complex<_Tp>&, const std::complex<_Tp>&)
     operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
     ^
/opt/rh/devtoolset-3/root/usr/include/c++/4.9.2/complex:381:5: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘const std::complex<_Tp>’
  ans = - (T)1.0 * b;
                 ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:287:11: note: template<class T> LA::vector<T> LA::operator*(LA::matrix<T>&, LA::vector<T>&)
 vector<T> operator*(matrix<T> &mat, vector<T> &vec){
           ^
../library/Linear_Algebra.hpp:287:11: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘LA::matrix<T>’
  ans = - (T)1.0 * b;
                 ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:275:11: note: template<class T> LA::matrix<T> LA::operator*(const T&, LA::matrix<T>&)
 matrix<T> operator*(const T &k, matrix<T> &mat){
           ^
../library/Linear_Algebra.hpp:275:11: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   types ‘LA::matrix<T>’ and ‘const LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ have incompatible cv-qualifiers
  ans = - (T)1.0 * b;
                 ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:261:11: note: template<class T> LA::matrix<T> LA::operator*(LA::matrix<T>&, LA::matrix<T>&)
 matrix<T> operator*(matrix<T> &mat1, matrix<T> &mat2){
           ^
../library/Linear_Algebra.hpp:261:11: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   ‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ is not derived from ‘LA::matrix<T>’
  ans = - (T)1.0 * b;
                 ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:145:11: note: template<class T> LA::vector<T> LA::operator*(const T&, const LA::vector<T>&)
 vector<T> operator*(const T &k, const vector<T> &obj){
           ^
../library/Linear_Algebra.hpp:145:11: note:   template argument deduction/substitution failed:
main.cpp:17:17: note:   deduced conflicting types for parameter ‘T’ (‘boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void, void>’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >’)
  ans = - (T)1.0 * b;
                 ^
In file included from main.cpp:4:0:
../library/ODE_solver.hpp: In instantiation of ‘void LA::RK_solver(LA::vector<T>&, LA::vector<T> (*)(const LA::vector<T>&), const T&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’:
main.cpp:30:34:   required from here
../library/ODE_solver.hpp:20:27: error: no match for ‘operator*’ (operand types are ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ and ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’)
  k2 = func(vec + 0.5 * dt * k1);
                           ^
../library/ODE_solver.hpp:20:27: note: candidates are:
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:145:11: note: template<class T> LA::vector<T> LA::operator*(const T&, const LA::vector<T>&)
 vector<T> operator*(const T &k, const vector<T> &obj){
           ^
../library/Linear_Algebra.hpp:145:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   deduced conflicting types for parameter ‘T’ (‘boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >’)
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:261:11: note: template<class T> LA::matrix<T> LA::operator*(LA::matrix<T>&, LA::matrix<T>&)
 matrix<T> operator*(matrix<T> &mat1, matrix<T> &mat2){
           ^
../library/Linear_Algebra.hpp:261:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘LA::matrix<T>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:275:11: note: template<class T> LA::matrix<T> LA::operator*(const T&, LA::matrix<T>&)
 matrix<T> operator*(const T &k, matrix<T> &mat){
           ^
../library/Linear_Algebra.hpp:275:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘LA::matrix<T>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:287:11: note: template<class T> LA::vector<T> LA::operator*(LA::matrix<T>&, LA::vector<T>&)
 vector<T> operator*(matrix<T> &mat, vector<T> &vec){
           ^
../library/Linear_Algebra.hpp:287:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘LA::matrix<T>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note: template<class B2, boost::multiprecision::expression_template_option ET, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<Backend, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note: template<class B, class B2, boost::multiprecision::expression_template_option ET> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<T2, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<T2, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   mismatched types ‘boost::multiprecision::detail::negate’ and ‘boost::multiprecision::detail::multiply_immediates’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const V&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   mismatched types ‘boost::multiprecision::detail::negate’ and ‘boost::multiprecision::detail::multiply_immediates’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   mismatched types ‘boost::multiprecision::detail::negate’ and ‘boost::multiprecision::detail::multiply_immediates’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note: template<class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<B, ET>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   mismatched types ‘boost::multiprecision::detail::negate’ and ‘boost::multiprecision::detail::multiply_immediates’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>’
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note: template<class B, boost::multiprecision::expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note: template<class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, V, boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const V&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note:   template argument deduction/substitution failed:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp: In substitution of ‘template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const V&) [with tag = boost::multiprecision::detail::multiply_immediates; Arg1 = double; Arg2 = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >; Arg3 = void; Arg4 = void; V = LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >]’:
../library/ODE_solver.hpp:20:27:   required from ‘void LA::RK_solver(LA::vector<T>&, LA::vector<T> (*)(const LA::vector<T>&), const T&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’
main.cpp:30:34:   required from here
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: error: no type named ‘type’ in ‘struct boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>, LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, void, void> >’
../library/ODE_solver.hpp: In instantiation of ‘void LA::RK_solver(LA::vector<T>&, LA::vector<T> (*)(const LA::vector<T>&), const T&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’:
main.cpp:30:34:   required from here
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::number<B, ET> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, ET>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note: template<class B, boost::multiprecision::expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const V& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const V&)
    operator * (const number<B, et_on>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const number<B, et_on>& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
    operator * (const V& a, number<B, et_off>&& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const V&)
    operator * (number<B, et_off>&& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
    operator * (const V& a, const number<B, et_off>& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const V&)
    operator * (const number<B, et_off>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:20:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k2 = func(vec + 0.5 * dt * k1);
                           ^
../library/ODE_solver.hpp:21:27: error: no match for ‘operator*’ (operand types are ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ and ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’)
  k3 = func(vec + 0.5 * dt * k2);
                           ^
../library/ODE_solver.hpp:21:27: note: candidates are:
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:145:11: note: template<class T> LA::vector<T> LA::operator*(const T&, const LA::vector<T>&)
 vector<T> operator*(const T &k, const vector<T> &obj){
           ^
../library/Linear_Algebra.hpp:145:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   deduced conflicting types for parameter ‘T’ (‘boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >’)
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:261:11: note: template<class T> LA::matrix<T> LA::operator*(LA::matrix<T>&, LA::matrix<T>&)
 matrix<T> operator*(matrix<T> &mat1, matrix<T> &mat2){
           ^
../library/Linear_Algebra.hpp:261:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘LA::matrix<T>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:275:11: note: template<class T> LA::matrix<T> LA::operator*(const T&, LA::matrix<T>&)
 matrix<T> operator*(const T &k, matrix<T> &mat){
           ^
../library/Linear_Algebra.hpp:275:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘LA::matrix<T>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:287:11: note: template<class T> LA::vector<T> LA::operator*(LA::matrix<T>&, LA::vector<T>&)
 vector<T> operator*(matrix<T> &mat, vector<T> &vec){
           ^
../library/Linear_Algebra.hpp:287:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘LA::matrix<T>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note: template<class B2, boost::multiprecision::expression_template_option ET, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<Backend, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note: template<class B, class B2, boost::multiprecision::expression_template_option ET> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<T2, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<T2, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   mismatched types ‘boost::multiprecision::detail::negate’ and ‘boost::multiprecision::detail::multiply_immediates’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const V&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   mismatched types ‘boost::multiprecision::detail::negate’ and ‘boost::multiprecision::detail::multiply_immediates’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   mismatched types ‘boost::multiprecision::detail::negate’ and ‘boost::multiprecision::detail::multiply_immediates’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note: template<class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<B, ET>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   mismatched types ‘boost::multiprecision::detail::negate’ and ‘boost::multiprecision::detail::multiply_immediates’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>’
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note: template<class B, boost::multiprecision::expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note: template<class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, V, boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const V&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note:   template argument deduction/substitution failed:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp: In substitution of ‘template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const V&) [with tag = boost::multiprecision::detail::multiply_immediates; Arg1 = double; Arg2 = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >; Arg3 = void; Arg4 = void; V = LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >]’:
../library/ODE_solver.hpp:21:27:   required from ‘void LA::RK_solver(LA::vector<T>&, LA::vector<T> (*)(const LA::vector<T>&), const T&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’
main.cpp:30:34:   required from here
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: error: no type named ‘type’ in ‘struct boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>, LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >, void, void> >’
../library/ODE_solver.hpp: In instantiation of ‘void LA::RK_solver(LA::vector<T>&, LA::vector<T> (*)(const LA::vector<T>&), const T&) [with T = boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >]’:
main.cpp:30:34:   required from here
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::number<B, ET> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, ET>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note: template<class B, boost::multiprecision::expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const V& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const V&)
    operator * (const number<B, et_on>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const number<B, et_on>& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
    operator * (const V& a, number<B, et_off>&& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const V&)
    operator * (number<B, et_off>&& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
    operator * (const V& a, const number<B, et_off>& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const V&)
    operator * (const number<B, et_off>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:21:27: note:   ‘boost::enable_if_c<true, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void> >::type {aka boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, double, boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >, void, void>}’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  k3 = func(vec + 0.5 * dt * k2);
                           ^
../library/ODE_solver.hpp:24:52: error: no match for ‘operator*’ (operand types are ‘double’ and ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’)
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
../library/ODE_solver.hpp:24:52: note: candidates are:
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:145:11: note: template<class T> LA::vector<T> LA::operator*(const T&, const LA::vector<T>&)
 vector<T> operator*(const T &k, const vector<T> &obj){
           ^
../library/Linear_Algebra.hpp:145:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   deduced conflicting types for parameter ‘T’ (‘double’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >’)
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:261:11: note: template<class T> LA::matrix<T> LA::operator*(LA::matrix<T>&, LA::matrix<T>&)
 matrix<T> operator*(matrix<T> &mat1, matrix<T> &mat2){
           ^
../library/Linear_Algebra.hpp:261:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘LA::matrix<T>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:275:11: note: template<class T> LA::matrix<T> LA::operator*(const T&, LA::matrix<T>&)
 matrix<T> operator*(const T &k, matrix<T> &mat){
           ^
../library/Linear_Algebra.hpp:275:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘LA::matrix<T>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:287:11: note: template<class T> LA::vector<T> LA::operator*(LA::matrix<T>&, LA::vector<T>&)
 vector<T> operator*(matrix<T> &mat, vector<T> &vec){
           ^
../library/Linear_Algebra.hpp:287:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘LA::matrix<T>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note: template<class B2, boost::multiprecision::expression_template_option ET, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<Backend, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note: template<class B, class B2, boost::multiprecision::expression_template_option ET> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<T2, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<T2, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const V&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note: template<class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<B, ET>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note: template<class B, boost::multiprecision::expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note: template<class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, V, boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const V&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::number<B, ET> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note: template<class B, boost::multiprecision::expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const V& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const V&)
    operator * (const number<B, et_on>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const number<B, et_on>& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
    operator * (const V& a, number<B, et_off>&& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const V&)
    operator * (number<B, et_off>&& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
    operator * (const V& a, const number<B, et_off>& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const V&)
    operator * (const number<B, et_off>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:52: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                                    ^
../library/ODE_solver.hpp:24:41: error: no match for ‘operator*’ (operand types are ‘double’ and ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’)
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
../library/ODE_solver.hpp:24:41: note: candidates are:
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:145:11: note: template<class T> LA::vector<T> LA::operator*(const T&, const LA::vector<T>&)
 vector<T> operator*(const T &k, const vector<T> &obj){
           ^
../library/Linear_Algebra.hpp:145:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   deduced conflicting types for parameter ‘T’ (‘double’ and ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> >’)
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:261:11: note: template<class T> LA::matrix<T> LA::operator*(LA::matrix<T>&, LA::matrix<T>&)
 matrix<T> operator*(matrix<T> &mat1, matrix<T> &mat2){
           ^
../library/Linear_Algebra.hpp:261:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘LA::matrix<T>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:275:11: note: template<class T> LA::matrix<T> LA::operator*(const T&, LA::matrix<T>&)
 matrix<T> operator*(const T &k, matrix<T> &mat){
           ^
../library/Linear_Algebra.hpp:275:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘LA::matrix<T>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from main.cpp:3:0:
../library/Linear_Algebra.hpp:287:11: note: template<class T> LA::vector<T> LA::operator*(LA::matrix<T>&, LA::vector<T>&)
 vector<T> operator*(matrix<T> &mat, vector<T> &vec){
           ^
../library/Linear_Algebra.hpp:287:11: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘LA::matrix<T>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note: template<class B2, boost::multiprecision::expression_template_option ET, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<Backend, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:418:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:411:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note: template<class B, class B2, boost::multiprecision::expression_template_option ET> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<boost::multiprecision::number<T2, ExpressionTemplates>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<T2, ExpressionTemplates> > > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<T2, ExpressionTemplates>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:404:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> > >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const V&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:397:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:390:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >&)
    operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:383:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note: template<class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<B, ET>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:376:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note: template<class B, boost::multiprecision::expression_template_option ET, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, Arg1> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<boost::multiprecision::detail::negate, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:369:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note: template<class V, class tag, class Arg1, class Arg2, class Arg3, class Arg4> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, V, boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>&)
    operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:360:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type>, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const V&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:354:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class tag2, class Arg1b, class Arg2b, class Arg3b, class Arg4b> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:348:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note: template<class tag, class Arg1, class Arg2, class Arg3, class Arg4, class B, boost::multiprecision::expression_template_option ET> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::number<B, ET> > boost::multiprecision::operator*(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, const boost::multiprecision::number<B, ET>&)
    operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:342:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note: template<class B, boost::multiprecision::expression_template_option ET, class tag, class Arg1, class Arg2, class Arg3, class Arg4> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiplies, boost::multiprecision::number<Backend, ExpressionTemplates>, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > boost::multiprecision::operator*(const boost::multiprecision::number<Backend, ExpressionTemplates>&, const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&)
    operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:336:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const V& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:330:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> >, boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, V> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const V&)
    operator * (const number<B, et_on>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:324:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2193:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note: template<class B> boost::multiprecision::detail::expression<boost::multiprecision::detail::multiply_immediates, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u> > boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>&)
    operator * (const number<B, et_on>& a, const number<B, et_on>& b)
    ^
/usr/local/include/boost/multiprecision/detail/et_ops.hpp:318:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)1u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
    operator * (const V& a, number<B, et_off>&& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:434:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const V&)
    operator * (number<B, et_off>&& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:426:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:418:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:411:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:404:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note: template<class V, class B> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const V&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
    operator * (const V& a, const number<B, et_off>& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:117:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   ‘LA::vector<boost::multiprecision::number<boost::multiprecision::backends::cpp_dec_float<100u> > >’ is not derived from ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note: template<class B, class V> typename boost::enable_if<boost::multiprecision::is_compatible_arithmetic_type<V, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >, boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> >::type boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const V&)
    operator * (const number<B, et_off>& a, const V& b)
    ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:108:4: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
In file included from /usr/local/include/boost/multiprecision/detail/default_ops.hpp:2192:0,
                 from /usr/local/include/boost/multiprecision/detail/generic_interconvert.hpp:9,
                 from /usr/local/include/boost/multiprecision/number.hpp:22,
                 from /usr/local/include/boost/multiprecision/cpp_dec_float.hpp:28,
                 from main.cpp:2:
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note: template<class B> boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u> boost::multiprecision::operator*(const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&, const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>&)
 BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)
                                        ^
/usr/local/include/boost/multiprecision/detail/no_et_ops.hpp:99:40: note:   template argument deduction/substitution failed:
In file included from main.cpp:4:0:
../library/ODE_solver.hpp:24:41: note:   mismatched types ‘const boost::multiprecision::number<B, (boost::multiprecision::expression_template_option)0u>’ and ‘double’
  vec = vec + (1.0/6.0) * dt * (k1 + 2.0 * k2 + 2.0 * k3 + k4);
                                         ^
make: *** [main.o] エラー 1
